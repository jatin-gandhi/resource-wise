"""Database service for executing SQL queries from agents."""

import time
from typing import Any

import structlog
from app.core.database import AsyncSessionLocal
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

logger = structlog.get_logger()


class DatabaseService:
    """Service for executing SQL queries generated by agents."""

    def __init__(self):
        """Initialize database service."""
        self.max_results = 1000  # Maximum results to return
        self.query_timeout = 30  # Query timeout in seconds

    async def execute_query(
        self, sql_query: str, params: dict[str, Any] | None = None
    ) -> dict[str, Any]:
        """Execute SQL query and return results.

        Args:
            sql_query: SQL query to execute
            params: Optional query parameters

        Returns:
            Dictionary containing query results and metadata
        """
        start_time = time.time()

        logger.info(
            "[DATABASE-SERVICE] Executing query",
            sql_preview=sql_query[:100] + "..." if len(sql_query) > 100 else sql_query,
            has_params=bool(params),
        )

        try:
            async with AsyncSessionLocal() as session:
                # Execute the query
                result = await session.execute(text(sql_query), params or {})

                # Handle different query types
                query_upper = sql_query.strip().upper()
                if query_upper.startswith("SELECT") or query_upper.startswith("WITH"):
                    return await self._handle_select_query(result, start_time)
                else:
                    # For INSERT/UPDATE/DELETE operations
                    await session.commit()
                    return await self._handle_modification_query(result, start_time)

        except Exception as e:
            execution_time = (time.time() - start_time) * 1000

            logger.error(
                "[DATABASE-SERVICE] Query execution failed",
                error=str(e),
                execution_time_ms=execution_time,
            )

            return {
                "success": False,
                "error": str(e),
                "error_type": self._classify_error(str(e)),
                "execution_time": execution_time,
                "db_results": [],
            }

    async def _handle_select_query(self, result, start_time: float) -> dict[str, Any]:
        """Handle SELECT query results.

        Args:
            result: SQLAlchemy query result
            start_time: Query start time

        Returns:
            Formatted SELECT query results
        """
        try:
            # Fetch all rows
            rows = result.fetchall()
            columns = list(result.keys()) if rows else []

            # Convert to list of dictionaries
            db_results = []
            for row in rows[: self.max_results]:  # Limit results
                row_dict = dict(zip(columns, row))
                db_results.append(row_dict)

            execution_time = (time.time() - start_time) * 1000

            logger.info(
                "[DATABASE-SERVICE] SELECT query completed",
                row_count=len(db_results),
                columns=len(columns),
                execution_time_ms=execution_time,
                truncated=len(rows) > self.max_results,
            )

            return {
                "success": True,
                "db_results": db_results,
                "row_count": len(db_results),
                "total_rows": len(rows),
                "columns": columns,
                "execution_time": execution_time,
                "truncated": len(rows) > self.max_results,
            }

        except Exception as e:
            execution_time = (time.time() - start_time) * 1000
            logger.error("[DATABASE-SERVICE] Error processing SELECT results", error=str(e))

            return {
                "success": False,
                "error": str(e),
                "error_type": "RESULT_PROCESSING_ERROR",
                "execution_time": execution_time,
                "db_results": [],
            }

    async def _handle_modification_query(self, result, start_time: float) -> dict[str, Any]:
        """Handle INSERT/UPDATE/DELETE query results.

        Args:
            result: SQLAlchemy query result
            start_time: Query start time

        Returns:
            Formatted modification query results
        """
        try:
            affected_rows = getattr(result, "rowcount", 0)
            execution_time = (time.time() - start_time) * 1000

            logger.info(
                "[DATABASE-SERVICE] Modification query completed",
                affected_rows=affected_rows,
                execution_time_ms=execution_time,
            )

            return {
                "success": True,
                "db_results": [{"affected_rows": affected_rows}],
                "row_count": 1,
                "affected_rows": affected_rows,
                "execution_time": execution_time,
            }

        except Exception as e:
            execution_time = (time.time() - start_time) * 1000
            logger.error("[DATABASE-SERVICE] Error processing modification results", error=str(e))

            return {
                "success": False,
                "error": str(e),
                "error_type": "RESULT_PROCESSING_ERROR",
                "execution_time": execution_time,
                "db_results": [],
            }

    def _classify_error(self, error_message: str) -> str:
        """Classify database errors into user-friendly categories.

        Args:
            error_message: Raw error message

        Returns:
            Error type classification
        """
        error_lower = error_message.lower()

        if "timeout" in error_lower or "timed out" in error_lower:
            return "TIMEOUT"
        elif "permission" in error_lower or "access denied" in error_lower:
            return "PERMISSION_ERROR"
        elif "syntax error" in error_lower or "invalid syntax" in error_lower:
            return "SYNTAX_ERROR"
        elif "connection" in error_lower or "connect" in error_lower:
            return "CONNECTION_ERROR"
        elif "does not exist" in error_lower or "unknown column" in error_lower:
            return "SCHEMA_ERROR"
        elif "duplicate" in error_lower or "unique constraint" in error_lower:
            return "CONSTRAINT_ERROR"
        else:
            return "UNKNOWN"


# Global database service instance
database_service = DatabaseService()
